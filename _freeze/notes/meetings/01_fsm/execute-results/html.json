{
  "hash": "a5c3175cd1d56af6c6e6068b97009bf8",
  "result": {
    "markdown": "---\ntitle: \"Regular Languages and Finite State Machines\"\ndate: 2024-01-16\ncategories:\n  - compling\n---\n\n## Where we're going:\n\nIn another class, we might just jump straight into learning about \"Regular Expressions\", which are very useful tools for searching for patterns in text.\n\nBut since this is *Computational* Linguistics, we should probably learn about what is \"regular\" about \"regular\" expressions, because it's related to formal language theory!\n\n## \"Formal Language Theory\" and \"Abstract Machines\"\n\n-   [Formal](../concepts/00_glossary.qmd#formal) Languages are systems of rules (i.e. a formal \"grammar\") for combining a set of strictly defined symbols.\n\n::: callout-tip\n## A small formal language\n\n-   $\\mathcal{L}$ is the language, which is a set that contains all, and only, the possible strings of $\\mathcal{L}$.\n\n-   $\\Sigma$ is the vocabulary of $\\mathcal{L}$.\n\n    -   $\\Sigma = \\{a,b\\}$\n\n-   $\\mathcal{N}$ Are the \"non-terminal nodes\" of $\\mathcal{L}$, of which we have 3.\n\n    -   $\\mathcal{N} = \\{S, A, B\\}$\n\n-   $\\mathcal{G}$ is the grammar of $\\mathcal{L}$. It contains 4 rules\n\n    1.  $S \\rightarrow aA$\n\n    2.  $A \\rightarrow aB$\n\n    3.  $A \\rightarrow aA$\n\n    4.  $B \\rightarrow b$\n\nWith the sets $\\mathcal{N}$, $\\mathcal{\\Sigma}$, and $\\mathcal{G}$, can we figure out which strings are, or are *not* in $\\mathcal{L}$?\n\n-   [ ] $ab$?\n\n-   [ ] $aab$?\n\n-   [ ] $b$?\n\n-   [ ] $aabb$?\n\n-   [ ] $abba$?\n\n-   [ ] $cab$?\n:::\n\n-   \"Automata\" and other abstract machines are ways of conceptualizing the possible or necessary computational operations and resources needed for different tasks, like identifying whether or not a string is in a language!\n\nWe'll start with the least complex[^1] machines, \"Finite State Automata\"\n\n[^1]: Complex in the sense of what they can *do*, not necessarily how easy it is to understand them.\n\n## Finite State Automata\n\nFinite\n\n:   Having a fixed, or *non infinite* amount of things\n\nState\n\n:   The current state, or status, of a system.\n\nAutomaton\n\n:   A machine\n\nFSAs have\n\n-   a fixed number of states\n\n-   a fixed number of *inputs* they can accept\n\n-   rules about how to change their state given an input.\n\n### Examples\n\n#### A light switch.\n\n\n```{mermaid}\nstateDiagram\n  direction LR\n  state \"Off\" as off\n  state \"On ðŸ’¡\" as on\n  \n  [*] --> off\n  on --> off: switch flip\n  off --> on: switch flip\n```\n\n\nStates\n\n:   On, Off\n\nInputs\n\n:   switch flip\n\n#### A metro turnstile\n\n\n```{mermaid}\nstateDiagram\n  direction LR\n  state \"Locked\" as l\n  state \"Unlocked\" as u\n  \n  [*] --> l\n  l --> l: push\n  l --> u: coin\n  u --> u: coin\n  u --> l: push\n```\n\n\nstates\n\n:   Locked, Unlocked\n\ninputs\n\n:   coin, push\n\n#### A Github Repo!\n\n\n```{mermaid}\nstateDiagram\n  state \"Local Synced with Remote\" as s\n  state \"Unstaged Changes\" as us\n  state \"All changes staged\" as st\n  state \"No uncommitted changes\" as com\n  [*] --> s\n  s --> us: Editing & Saving\n  us --> us: Editing & Saving\n  us --> st: Staging all changes\n  st --> us: Editing & Saving\n  st --> com: Committing\n  com --> us: Editing & Saving\n  com --> s: Push\n```\n\n\nstates\n\n:   Local Synced with Remote, Unstaged Changes, All Changes Staged, No Uncommitted Changes\n\ninputs\n\n:   Editing & Saving, Staging all Changes, Committing, Push\n\n#### The Batman Theme Song\n\n::: {.callout-note collapse=\"true\"}\n## Batman!\n\nNa na na na na na na na na na na na\\\nBatman!\\\nNa na na na na na na na na na na na\\\nBatman!\\\nNa na na na na na na na na na na na\\\nBatman!\\\nNa na na na na na na na na na na na\\\nBatman!\\\nNa na na na na na na na na na na na\\\nBatman! Batman! Batman!\\\nNa na na na na na na na na na na na\\\nBatman!\n:::\n\n\n```{mermaid}\nstateDiagram\n  direction LR\n  [*] --> a: Na\n  a --> b: na\n  b --> c: na\n  c --> d: na\n  d --> e: na\n  e --> f: na\n  f --> g: na\n  g --> h: na\n  h --> i: na\n  i --> j: na\n  j --> k: na\n  k --> l: na\n  l --> batman1: Batman!\n  batman1 --> a: Na\n  batman1 --> batman2: Batman!\n  batman2 --> batman3: Batman!\n  batman3 --> a: Na\n  batman1 --> [*]: Îµ\n```\n\n\nStates\n\n:   a-l, batman1, batman2, batman3\n\nInputs\n\n:   Na, na, Batman!\n\n## Automata and Formal Grammars\n\nIf you have\n\n-   some formal Grammar $\\mathcal{G}$\n\nthat you use to generate\n\n-   the strings of language $\\mathcal{L}$\n\nThere is *some* Automaton (maybe *not* a finite state automaton!) that can decide whether nor not a string is in $\\mathcal{L}$ or not.\n\nThis relationship between automata of various complexity and formal grammars/languages is called the \"Chomsky Hierarchy.\"\n\n![](assets/chomsky.png){fig-align=\"center\" width=\"80%\"}\n\n## Returning to our small formal language\n\nHere's the grammar rules we had for our grammar\n\n-   $\\mathcal{G}$ is the grammar of $\\mathcal{L}$. It contains 4 rules\n\n    1.  $S \\rightarrow aA$\n\n    2.  $A \\rightarrow aB$\n\n    3.  $A \\rightarrow aA$\n\n    4.  $B \\rightarrow b$\n\n### Using the grammar to generate a string\n\nWe can build up a string by choosing rules and applying them\n\n::: columns\n::: {.column width=\"40%\"}\nStart\n:::\n\n::: {.column width=\"50%\"}\n\n```{mermaid}\n%%| fig-align: center\nflowchart TD\n  S\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n::: columns\n::: {.column width=\"30%\"}\n1.  $S\\rightarrow aA$\n:::\n\n::: {.column width=\"50%\"}\n\n```{mermaid}\n%%| fig-align: center\nflowchart TD\n  S --> a1[\"a\"]\n  S --> A1[\"A\"]\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n::: columns\n::: {.column width=\"30%\"}\n3.  $A \\rightarrow aA$\n:::\n\n::: {.column width=\"50%\"}\n\n```{mermaid}\n%%| fig-align: center\nflowchart TD\n  S --> a1[\"a\"]\n  S --> A1[\"A\"]\n  A1 --> a2[\"a\"]\n  A1 --> A3[\"A\"]\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n::: columns\n::: {.column width=\"30%\"}\n2.  $A \\rightarrow aB$\n:::\n\n::: {.column width=\"50%\"}\n\n```{mermaid}\n%%| fig-align: center\nflowchart TD\n  S --> a1[\"a\"]\n  S --> A1[\"A\"]\n  A1 --> a2[\"a\"]\n  A1 --> A2[\"A\"]\n  A2 --> a3[\"a\"]\n  A2 --> B\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n::: columns\n::: {.column width=\"30%\"}\n4.  $B \\rightarrow b$\n:::\n\n::: {.column width=\"50%\"}\n\n```{mermaid}\n%%| fig-align: center\nflowchart TD\n  S --> a1[\"a\"]\n  S --> A1[\"A\"]\n  A1 --> a2[\"a\"]\n  A1 --> A2[\"A\"]\n  A2 --> a3[\"a\"]\n  A2 --> B\n  B --> b\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\nResult: $aaab$\n\n### Defining a FSA to recognize the language \n\n\n```{mermaid}\nstateDiagram\n  direction LR\n  \n  [*]-->p\n  p --> q: a\n  q --> q: a\n  q --> [*]: b\n  \n```\n\n\n-   If we take strings, generated by $\\mathcal{G}$ and feed them to this FSA one-by-one, we should arrive at the \"accepting\" state without any symbols left over.\n\n-   If we take a string, generated by some unknown grammar, pass it through this FSA, and arrive at the \"accepting\" state without any symbols left over, then it *could* have been generated by $\\mathcal{G}$.\n\n-   If we take a string, and pass it through this FSA, and either never get to the accepting state, or have symbols left over, then it *couldn't* have been generated by $\\mathcal{G}$, and isn't in $\\mathcal{L}$.\n\n## What does this have to do with \"Regular Expressions?\"\n\n\"Regular Expressions\" are a concise, computery way, to define finite state automata that take text as input strings and return matches. That is, regular expressions can identify strings that belong to \"regular\" languages.\n\nWe'll talk about details later, but if I wasn't sure of someone was using British spelling or American spelling, I could write a RegEx to match either `color` or `colour`.\n\n::: columns\n::: {.column width=\"30%\"}\n`colou?r`\n:::\n\n::: {.column width=\"50%\"}\n\n```{mermaid}\nstateDiagram\n  direction LR\n  [*] --> 1\n  1 --> 2: c\n  2 --> 3: o\n  3 --> 4: l\n  4 --> 5: o\n  5 --> 6: u\n  5 --> [*]: r\n  6 --> [*]: r\n```\n\n:::\n:::\n\n### Limitations of RegEx\n\nBecause Regular Expressions define a finite state automaton, and FSAs can only successfully recognize regular languages, that means you can't use Regular Expressions (reliably) to recognize any more complex language.\n\nFor example, HTML pages use \"tags\" to define where text elements begin and end. In this code snippet, the opening `<p>` tag says a paragraph is beginning, and the closing `</p>` says the paragraph is ending. The opening `<strong>` tag says the text is turning bold, and the closing `</strong>` tag says the text is turning regular again.\n\n``` html\n<p>\n  This is a paragraph with \n  <strong>\n    bold text\n  </strong>\n  .\n</p>\n```\n\n\n```{html}\n<p>\n  This is a paragraph with \n  <strong>\n    bold text\n  </strong>\n  .\n</p>\n```\n\n",
    "supporting": [
      "01_fsm_files"
    ],
    "filters": [],
    "includes": {}
  }
}