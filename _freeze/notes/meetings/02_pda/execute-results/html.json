{
  "hash": "a394c750491a754144218b724d4c60f6",
  "result": {
    "markdown": "---\ntitle: \"Pushdown Automata and Context Free Languages\"\ndate: 2024-01-23\ncategories:\n  - compling\n---\n\n\n## More like a rip-off machine\n\nIn the notes on [Finite State Automata](01_fsm.qmd), we looked at this turnstile finite state automaton.\n\n\n```{mermaid}\nstateDiagram\n  direction LR\n  state \"Locked\" as l\n  state \"Unlocked\" as u\n  \n  [*] --> l\n  l --> l: push\n  l --> u: coin\n  u --> u: coin\n  u --> l: push\n```\n\n\nAn annoying thing about this turnstile is that if you don't know how it works, it will rip you off!\n\n::: callout-tip\n## A scenario\n\nRobin approaches the finite-state turnstile with two of their friends. They think\n\n> There's three of us, and I have three tokens. I'll speed things up and be a good friend by popping three tokens into the machine, and then all three of us can pop through.\n:::\n\nRobin is expecting a pattern like this to happen\n\n\n{{< fa coins >}}, {{< fa coins >}}, {{< fa coins >}}, {{< fa person >}}, {{< fa person >}}, {{< fa person >}}\n\n\n\nLittle does Robin know that the way this turnstile works is that after you put a coin into the slot, the coin rolls past and triggers the unlocking mechanism and goes straight into the collection bin. If the turnstile is already unlocked, the coin just rolls into the collection bin. It doesn't have any \"memory\" of how many coins it's been fed, so after one person walks through, the turnstile relocks.\n\nSo here's what happens to Robin and their friends\n\n| Input             | New State |\n|-------------------|-----------|\n|                   | Locked    |\n| {{< fa coins >}}  | Unlocked  |\n| {{< fa coins >}}  | Unlocked  |\n| {{< fa coins >}}  | Unlocked  |\n| {{< fa person >}} | Locked    |\n\nWith the turnstile locked again, Robin's two friends can't get through unless they insert yet another token!\n\n## A Pushdown Automaton\n\nRobin was really upset and embarrassed at losing two whole tokens to the rip-off (finite state) machine in front of their friends. They vowed to invent a better turnstile so no one would ever have to face that kind of embarrassment again.\n\n### Incorporating a memory\n\nThe problem with the finite-state turnstile is that it has no \"memory\" of how many coins it's been fed. Robin's new prototype works like so:\n\n-   Every time someone inserts a coin into Robin's turnstile, it lands in a little collection tray. If someone inserts multiple coins, they form a stack of coins.\n\n-   If there is even one coin in the stack, the turnstile is unlocked.\n\n-   Any time someone pushes through the turnstile, the collection tray bounces one coin off of the stack.\n\nEven this simple system gets a little unwieldy to represent in the same kind of state diagram. So, here's the last one of these we'll see for a bit.\n\n\n```{mermaid}\nstateDiagram\n  direction LR\n  state \"Locked\" as l\n  state \"Unlocked\" as u\n  state coin_fork1 <<fork>>\n  state coin_fork2 <<fork>>\n  state pop1 <<fork>>\n  state pop2 <<fork>>\n  state choice_state <<choice>>\n  state \"Stack\" as s\n  \n  [*] --> l\n  l --> l : push\n  l --> coin_fork1: coin\n  coin_fork1 --> u\n  coin_fork1 --> s: +1\n  u --> coin_fork2: coin\n  coin_fork2 --> u\n  coin_fork2 --> s: +1\n  \n  u --> choice_state: push\n  choice_state --> pop1: if Stack > 1\n  pop1 --> s: -1\n  pop1 --> u\n  \n  choice_state --> pop2: if Stack == 1\n  pop2 --> s: -1\n  pop2 --> l\n```\n\n\n### Using the Pushdown Turnstile\n\nWith Robin's new Pushdown Turnstile installed at metro stations everywhere, they bring their two friends back to the scene of the crime, and retry their three-coins, three-people strategy. Here's what happens.\n\n| Input             | New State | Coin Stack |\n|-------------------|-----------|------------|\n|                   | Locked    | 0          |\n| {{< fa coins >}}  | Unlocked  | 1          |\n| {{< fa coins >}}  | Unlocked  | 2          |\n| {{< fa coins >}}  | Unlocked  | 3          |\n| {{< fa person >}} | Unlocked  | 2          |\n| {{< fa person >}} | Unlocked  | 1          |\n| {{< fa person >}} | Locked    | 0          |\n\n### Generalizing the pattern\n\nThe way this turnstile works, generally, is that if you put in $n$ coins, $n$ people will be able to push through. Another way of notating that sequence of events is {{< fa coins >}}$^n${{< fa person >}}$^n$. In the more formal-language-theory world, these kinds of patterns are usually labeled $a^nb^n$.\n\nAnother way to think about these $a^nb^n$ systems is in terms of bracket matching. If we replace each {{< fa coins >}} symbol with `[` and each {{< fa persopn >}} symbol with `]`, then we get a pattern that looks like this:\n\n```         \n[\n[\n[\n]\n]\n]\n```\n\nThe requirement for the language is that every opening bracket `[` needs to get matched with a closing bracket `]`.\n\n## Context Free Grammars\n\nWe get nested, bracket matching patterns in natural language all the time. For example the person-number agreement in this sentence.\n\n::: {style=\"font-size: 1.2em\"}\nThe [person]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} who [I]{style=\"color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"}, the guy [you]{style=\"color: white;background: #117733; display: inline-block; border-radius:10%; padding-left:1%; padding-right:1%;\"} [are]{style=\"color: white;background: #117733; display: inline-block; border-radius:10%; padding-left:1%; padding-right:1%;\"} looking at, [am]{style=\"color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} talking to [is]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} not listening.\n:::\n\nIf the form of *be* in this sentence were generated by a Regular Grammar, to be parsed with a Finite State Automaton, once the \"you\" subject appears in the sentence, every following form of *be* would have to be \"are\" the rest of the way.\n\n::: {style=\"font-size: 1.2em\"}\n**\\***The [person]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} who [I]{style=\"color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"}, the guy [you]{style=\"color: white;background: #117733; display: inline-block; border-radius:10%; padding-left:1%; padding-right:1%;\"} [are]{style=\"color: white;background: #117733; display: inline-block; border-radius:10%; padding-left:1%; padding-right:1%;\"} looking at, [are]{style=\"color: white;background: #117733; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} talking to [are]{style=\"color: white;background: #117733; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} not listening.\n:::\n\nSince the first sentence *is* how English and other languages work, we'd conclude that natural language is, at least, Context Free.\n\n### Context Free Rules\n\n::: columns\n::: {.column width=\"45%\"}\nRegular rules can look like this:\n\n$$\nA \\rightarrow aA\n$$\n:::\n\n::: {.column width=\"45%\"}\nContext free rules can look like this: $$\nA \\rightarrow aAb\n$$\n:::\n:::\n\nReturning to this html snippit:\n\n``` html\n<p>\n  This is a paragraph with \n  <strong>\n    bold text.\n  </strong>\n</p>\n```\n\nRules of a context free grammar that could give rise to this well-formed html are:\n\n$$\nD \\rightarrow <p>C</p>\n$$\n\n$$\nC \\rightarrow words\n$$\n\n$$\nC \\rightarrow words S\n$$\n\n$$\nS \\rightarrow <strong>C</strong>\n$$\n\n\n```{mermaid}\nflowchart TD\n\n  D --> p1[\"p\"]\n  D --> C1[\"C\"]\n  D --> p2[\"/p\"]\n\n  C1 --> w1[\"This is a paragraph with\"]\n  C1 --> S\n\n  S --> s1[\"strong\"]\n  S --> C2[\"C\"]\n  S --> s2[\"/strong\"]\n\n  C2 --> w2[\"bold text.\"]\n\n```\n\n\n### A PDA for this grammar\n\nHere's a way we'd describe a Pushdown Automaton that decides whether or not a document is generated by this grammar:\n\n-   Each time it encounters an opening `<tag>`, it adds it to the stack, and when it encounters a closing `</tag>`, it pops it from the stack.\n\n<!-- -->\n\n-   When it encounters a closing `</tag>`, it *has* to match the opening `<tag>` that's at the top of the stack.\n\n-   When it gets to the end of the document, the stack needs to be empty.\n\nHere's a table showing how that'd play out\n\n| Input                                  | event           | Stack                                                                          |\n|------------------------|------------------------|------------------------|\n| `<p>`                                  | push `<p>`      | [`<p>`]{style=\"display: inline-block; border: 1px solid #CC6677;\"}             |\n| `This`, `is`, `a`, `paragraph`, `with` |                 | [`<p>`]{style=\"display: inline-block; border: 1px solid #CC6677;\"}             |\n| `<strong>`                             | push `<strong>` | [`<strong>`]{style=\"display: inline-block; border: 1px solid #CC6677;\"}, `<p>` |\n| `bold`, `text.`                        |                 | [`<strong>`]{style=\"display: inline-block; border: 1px solid #CC6677;\"}, `<p>` |\n| `</strong>`                            | pop `<strong>`  | [`<p>`]{style=\"display: inline-block; border: 1px solid #CC6677;\"}             |\n| `</p>`                                 | pop `<p>`       |                                                                                |\n\nOne consequence of the rule that tags need to match when you pop them is that the following is *not* valid html.\n\n``` html\n<p>\n  This is <strong>invalid!\n</p>\n</strong>\n```\n\nIf you were to reason through the state of the stack after the opening `<strong>` tag, it would look like\n\n> [`<strong>`]{style=\"display: inline-block; border: 1px solid #CC6677;\"}, `<p>`\n\nThen, when you feed it `</p>`, it doen't match the tag at the top of the stack, so we'd get an error of some sort.\n\n## Limits of Pushdown Automata\n\nAn office building has installed a version of Robin's turnstile. Each person who enters the building has to insert their id card, and the machine scans it and spits it out the other side when a person pushes through.\n\n[Robin]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} approaches the turnstile with their friends [Skylar]{style=\"color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} and [Alex]{style=\"color: white;background: #117733; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"}. Both [Skylar]{style=\"color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} and [Alex]{style=\"color: white;background: #117733; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} have their hands full carrying packages into the building, so [Robin]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} tries to be helpful and insert all of their id cards first, so they can then pass through. They're walking through in the order\n\n1.  [Robin]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"}\n2.  [Skylar]{style=\"color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"}\n3.  [Alex]{style=\"color: white;background: #117733; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"}\n\nSo Robin puts their ID cards into the turnstile in that order. Here's how it works out\n\n| Input                                          | Action                                              | Stack                                                                                                                                       |\n|------------------|------------------|------------------------------------|\n| [{{< fa id-card >}}]{style=\"color: #4477AA;\"}  | push [{{< fa id-card >}}]{style=\"color: #4477AA;\"}  | [{{< fa id-card >}}]{style=\"color: #4477AA;\"}                                                                                               |\n| [{{< fa id-card >}}]{style=\"color: #CC6677;;\"} | push [{{< fa id-card >}}]{style=\"color: #CC6677;;\"} | [{{< fa id-card >}}]{style=\"color: #CC6677;;\"}, [{{< fa id-card >}}]{style=\"color: #4477AA;\"}                                               |\n| [{{< fa id-card >}}]{style=\"color: #117733\"}   | push [{{< fa id-card >}}]{style=\"color: #117733\"}   | [{{< fa id-card >}}]{style=\"color: #117733\"}, [{{< fa id-card >}}]{style=\"color: #CC6677;;\"}, [{{< fa id-card >}}]{style=\"color: #4477AA;\"} |\n| [{{< fa person >}}]{style=\"color: #4477AA;\"}   | pop [{{< fa id-card >}}]{style=\"color: #117733\"}    | [{{< fa id-card >}}]{style=\"color: #CC6677;;\"}, [{{< fa id-card >}}]{style=\"color: #4477AA;\"}                                               |\n|                                                | ðŸš¨                                                  |                                                                                                                                             |\n\nOh no! The turnstile has handed [Robin]{style=\"color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} [Alex's]{style=\"color: white;background: #117733; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;\"} id card! What a mess!\n\n### Beyond Context Free\n\nRobin was expecting a sequence like this\n\n> [{{< fa id-card >}}]{style=\"color: #4477AA;\"}, [{{< fa id-card >}}]{style=\"color: #CC6677;;\"}, [{{< fa id-card >}}]{style=\"color: #117733\"}, [{{< fa person >}}]{style=\"color: #4477AA;\"}, [{{< fa person >}}]{style=\"color: #CC6677;;\"}, [{{< fa person >}}]{style=\"color: #117733\"}\n\nThis involves so-called \"crossing dependencies\", which can't be recognized by a Pushdown Automaton, which means they involve a more complex grammar than context free rules.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n(@my-label) <style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style><div data-gloss=\"\">\n  <p class=\"gloss__line--original\">ASBC (nÂº 100622)</p>\n  <p>dass mer <span style='color: #4477AA;'>d' chind</span></p>\n  <p>that we the children-acc</p>\n  <p class=\"gloss__line--free\">\"Waaaaa, she began to wail.\"</p>\n</div><script>document.addEventListener('DOMContentLoaded', function() {Leipzig({lastLineFree: false}).gloss();});</script>\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/leipzig-0.8.0/leipzig.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leipzig-0.8.0/leipzig.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}