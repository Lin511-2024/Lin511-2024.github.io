---
title: "Pushdown Automata and Context Free Languages"
date: 2024-01-23
categories:
  - compling
---

## More like a rip-off machine

In the notes on [Finite State Automata](01_fsm.qmd), we looked at this turnstile finite state automaton.

```{mermaid}
stateDiagram
  direction LR
  state "Locked" as l
  state "Unlocked" as u
  
  [*] --> l
  l --> l: push
  l --> u: coin
  u --> u: coin
  u --> l: push
```

An annoying thing about this turnstile is that if you don't know how it works, it will rip you off!

::: callout-tip
## A scenario

Robin approaches the finite-state turnstile with two of their friends. They think

> There's three of us, and I have three tokens. I'll speed things up and be a good friend by popping three tokens into the machine, and then all three of us can pop through.
:::

Robin is expecting a pattern like this to happen

{{< fa coins >}}, {{< fa coins >}}, {{< fa coins >}}, {{< fa person >}}, {{< fa person >}}, {{< fa person >}}

Little does Robin know that the way this turnstile works is that after you put a coin into the slot, the coin rolls past and triggers the unlocking mechanism and goes straight into the collection bin. If the turnstile is already unlocked, the coin just rolls into the collection bin. It doesn't have any "memory" of how many coins it's been fed, so after one person walks through, the turnstile relocks.

So here's what happens to Robin and their friends

| Input             | New State |
|-------------------|-----------|
|                   | Locked    |
| {{< fa coins >}}  | Unlocked  |
| {{< fa coins >}}  | Unlocked  |
| {{< fa coins >}}  | Unlocked  |
| {{< fa person >}} | Locked    |

With the turnstile locked again, Robin's two friends can't get through unless they insert yet another token!

## A Pushdown Automaton

Robin was really upset and embarrassed at losing two whole tokens to the rip-off (finite state) machine in front of their friends. They vowed to invent a better turnstile so no one would ever have to face that kind of embarrassment again.

### Incorporating a memory

The problem with the finite-state turnstile is that it has no "memory" of how many coins it's been fed. Robin's new prototype works like so:

-   Every time someone inserts a coin into Robin's turnstile, it lands in a little collection tray. If someone inserts multiple coins, they form a stack of coins.

-   If there is even one coin in the stack, the turnstile is unlocked.

-   Any time someone pushes through the turnstile, the collection tray bounces one coin off of the stack.

Even this simple system gets a little unwieldy to represent in the same kind of state diagram. So, here's the last one of these we'll see for a bit.

```{mermaid}
stateDiagram
  direction LR
  state "Locked" as l
  state "Unlocked" as u
  state coin_fork1 <<fork>>
  state coin_fork2 <<fork>>
  state pop1 <<fork>>
  state pop2 <<fork>>
  state choice_state <<choice>>
  state "Stack" as s
  
  [*] --> l
  l --> l : push
  l --> coin_fork1: coin
  coin_fork1 --> u
  coin_fork1 --> s: +1
  u --> coin_fork2: coin
  coin_fork2 --> u
  coin_fork2 --> s: +1
  
  u --> choice_state: push
  choice_state --> pop1: if Stack > 1
  pop1 --> s: -1
  pop1 --> u
  
  choice_state --> pop2: if Stack == 1
  pop2 --> s: -1
  pop2 --> l
```

### Using the Pushdown Turnstile

With Robin's new Pushdown Turnstile installed at metro stations everywhere, they bring their two friends back to the scene of the crime, and retry their three-coins, three-people strategy. Here's what happens.

| Input             | New State | Coin Stack |
|-------------------|-----------|------------|
|                   | Locked    | 0          |
| {{< fa coins >}}  | Unlocked  | 1          |
| {{< fa coins >}}  | Unlocked  | 2          |
| {{< fa coins >}}  | Unlocked  | 3          |
| {{< fa person >}} | Unlocked  | 2          |
| {{< fa person >}} | Unlocked  | 1          |
| {{< fa person >}} | Locked    | 0          |

### Generalizing the pattern

The way this turnstile works, generally, is that if you put in $n$ coins, $n$ people will be able to push through. Another way of notating that sequence of events is {{< fa coins >}}$^n${{< fa person >}}$^n$. In the more formal-language-theory world, these kinds of patterns are usually labeled $a^nb^n$.

Another way to think about these $a^nb^n$ systems is in terms of bracket matching. If we replace each {{< fa coins >}} symbol with `[` and each {{< fa persopn >}} symbol with `]`, then we get a pattern that looks like this:

```         
[
[
[
]
]
]
```

The requirement for the language is that every opening bracket `[` needs to get matched with a closing bracket `]`.

## Context Free Grammars

We get nested, bracket matching patterns in natural language all the time. For example the person-number agreement in this sentence.

::: {style="font-size: 1.2em"}
The [person]{style="color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;"} who [I]{style="color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;"} [am]{style="color: white;background: #CC6677; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;"} talking to [is]{style="color: white;background: #4477AA; display: inline-block;border-radius:10%;padding-left:1%;padding-right:1%;"} not listening.
:::

### Context Free Rules

:::{.columns}

:::{.column width="45%"}
Regular rules can look like this:

$$
A \rightarrow aA
$$

:::


:::{.column width="45%"}
Context free rules can look like this:
$$
A \rightarrow aAb
$$


:::

:::

Returning to this html snippit:

``` html
<p>
  This is a paragraph with 
  <strong>
    bold text.
  </strong>
</p>
```

Rules of a context free grammar that could give rise to this well-formed html are:

$$
D \rightarrow <p>C</p>
$$

$$
C \rightarrow words
$$

$$
C \rightarrow words S
$$

$$
S \rightarrow <strong>C</strong>
$$

```{mermaid}
flowchart TD

  D --> p1["p"]
  D --> C1["C"]
  D --> p2["/p"]

  C1 --> w1["This is a paragraph with"]
  C1 --> S

  S --> s1["strong"]
  S --> C2["C"]
  S --> s2["/strong"]

  C2 --> w2["bold text."]

```

## Limits of Pushdown Automata

One thing Pushdown Automata *can't* handle is so-called "crossing" dependencies. 